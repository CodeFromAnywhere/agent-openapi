# May 2024

- ✅ Setup boilerplate
- ✅ Fix routing issues
- ✅ Implement refresh propagation to localStorage
- ✅ change pattern data.actionschema to allow for `-_~.AZ`
- ✅ make AgentOpenapi item and create crud-openapi at https://data.actionschema.com/agent-openapi/openapi.json
- ✅ create npm script that turns openapi into an SDK client
- ✅ ensure `databaseId` goes lowercase upon creation
- ✅ Fix bug so the script `npm run crud` actually works
- ✅ Implement refresh storage
- ✅ Implement OpenAPI

# June 2024

- ✅ Implement simple `agent.actionschema.com/asst_xxxx/message` with `openai` SDK
- ✅ Expose `agent.actionschema.com/asst_xxxx/agent.json` with instructions & tools taken from openai's API.
- 🤔 Revelation: `Asssistant` doesn't contain any information about the API URL, paths, or Authentication. This makes this whole idea problematic as tools cannot be accessed without external implementation. Therefore, instead, we could build `agent.actionschema.com/[agentSlug]/message` and `agent.json` and `openapi.json` but not with login to openai.

## Refactor Agents, Week of June 3rd

✅ Instead of `refreshOpenai`, let's create agents via a form in which you provide an `openapiUrl` and then you can manage further configuration. Ensure default instructions and other settings are generated by default.

✅ Instead, store this for OpenAIAgent: `{ agentSlug, openaiSecretKey, deepgramToken, authToken, name, instructions, model, top_p, temperature, openapiAuth, openapiUrl, functionsCalculated }`

✅ Rename `details.json` to `GET details` and ensure it provides all details including `openapiAuth` only if `Authorization` header is set to match authToken.

✅ Refactor `/message` to not use an assistant

✅ To support functions, it needs to call the OpenAPI based on something returned as step. https://platform.openai.com/docs/assistants/tools/function-calling/quickstart

✅ Ensure authToken gets added automatically for new agents

✅ Confirm an agent with people-openapi tool works.

✅ Ensure `message` can also handle images by url

❌ Chat Completions doesn't support other files, so let's leave it at this for now. We could add logic we had in whatsapp-twilio stuff to also handle other types of files, but it's probably better to leave this and have a broader set of models that we support without increasing somplexity.

✅ Ensure `message` response can also handle more than just text

## Fixes June 7th

- ✅ Fix openapi

  - ✅ remove `deepgramToken` from openapi for making an agent.
  - ✅ also change order: required first!
  - ✅ model should have some options only

- ✅ Fix `<OpenapiForms>`

  - ✅ `/message` input should be a textarea
  - ✅ make a button to generate a twilio url: `prompt(deepgramToken)`
  - ✅ make the textareas a bit bigger

- ✅ Allow updating an agent: link "Update" to prefil form with existing agent

- ✅ When seeing an agent on /[agentSlug], add twilio-phone-callback and twilio-message-callback URLs so its easy to setup

# Make tools work

Fix when using openapi tools

- ✅ url is incorrect (debug this)
- ✅ test `/message` and confirm it works
- ✅ After tools work in message, test if the tool works in deepgram as well

# 25 june 2024

- Learning: oAuth2 is user-based authorization. Therefore if we need an agent to execute tools with this security mechanism, we need a user authtoken, which is an extra datastructure that we need to store.
- There isn't a straightforward solution to this. Ideally we want to make it as generic as possible. Let's take some time to think this through.
- Every operation in an OpenAPI will be a tool. Also we may make things dynamic. Users can authenticate to tools on a need-to-know basis, meaning there may always be tools we didn't authorize to yet.
- OpenAI only supports 1 securitySchema, which is problematic. Technically however, it's possible to have unlimited amount of security schemas, and a different security setting per operation/endpoint.
- The end-client can be a web-browser, chatgpt, a phonecall, whatsapp, or an API.
- Clerk isn't the way because it allows us to login in third-party apps but it doesn't give us api access. That's not what it's for. And we want to have the ability to have no login at all in some cases.

Before I continue, let's explore GPTs a bit more. Can I make one work with oauth2? https://www.youtube.com/watch?v=6HFp0ISO4XI . Should I compromise on features and only support what GPTs support, or just go all out and build the best one possible for myself?

# june 29, 2024

Today was a historic day. I've 80% done with tool use with support for oauth2! This is something that - in my opinion - should be part of any LLM.

## Datastructures

- ✅ Create a `agent-user-thread` CRUD (a thread is all messages)
- ✅ Create a `agent-user` CRUD `{ [userAuthToken]: { threadIds:string[], keys: {[securitySchemeKey]:string}}}`
- ✅ Create a `agent-admin` CRUD: `{ [adminAuthToken]:{ openapis: {url:string,Authorization?:string}[], oauthDetails: {service,securitySchemeKey,appId,appSecret}[] } }`
- ✅ Now that I am using 4 cruds, better make a single `migration.sh` script upserting + installing them.
- ✅ Create a function `generateSdk(openapi[])` that responds with a string containing a typescript SDK for that api.

## Datastructure implementation

- ✅ Use `agent-admin` properly at `upsertAgent`
- ✅ Ensure to retreive the securityScheme object and threadIds based on the `agent-user`
- ✅ Ensure to retreive the thread

## Extra message functionality

- ✅ add thread to the messages.
- ✅ store response in thread, respond with threadId
- ✅ File support: simply put the url in the message if the model doesnt support it, so it can enact tools.

## OAuth tool use 👨‍🍳

- ✅ Break tool-loop up into 2 maps: preperation/auth-step, and execution
- ✅ Split up the main message function into multiple composed responsibilities. Composition over inheritance.
- ✅ In the preparation step, break out put the break-out logic right.
- ✅ If one tool is missing, let's break out of the tool-loop and respond with login url(s)

Almost done with oauth2-based tool use. The whole thing will be a lot more complex as we'll have datastructures for admins, users, agents, and threads, which is needed due to the fact that we need proper tool use.

# Make `/message` work (july 8th, 2024)

✅ Hardcode the `X_AGENT_AUTH_TOKEN` header in the proxy using a `process.env` key.

✅ Finish `mergeOpenapis` (merge array)

✅ Create a page for `mergeOpenapis` and then use it to merge the signup endpoints of both agents.

✅ Create a `message.html` page that calls `/userSignup` for an agent with an arbitrary token and sets it to localStorage. Ensure `Authorization` is provided from `localStorage` and the html can call `message` with a good loading indicator.

🙃 I have been stuck now trying to make the `message` endpoint work for almost an hour. As it's almost 1AM ill call it a day. The problem is that multiple things seem to be unstable and badly logged. I don't know anything as I haven't properly tested agent creation after i changed loads in it. Next step.... Make the agent message api work. ✅ Ok finally just before i wanna quit, i did a step back, and found out that i don't have the `.env` variables set for agent-openapi. DAMN! so dumb. but it still doesn't work.
